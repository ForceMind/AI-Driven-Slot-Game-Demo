# 高级老虎机引擎架构：扩展性与动态卷轴解决方案

## 1. 问题背景

当前引擎采用 **"预计算分桶 (Pre-calculation & Bucketing)"** 策略：
1.  启动时遍历（或采样）所有可能的卷轴停止位置组合 ($16^5 \approx 100万$)。
2.  计算每个组合的结果，并将其索引存入对应的 `Bucket`（如 `Win_Tier_1`, `Loss`）。
3.  旋转时，先根据 RTP 选桶，再从桶里随机取一个结果。

**面临的挑战：**
1.  **组合爆炸 (State Space Explosion)**：如果卷轴长度变为 50，组合数 $50^5 = 3.125亿$。内存和初始化时间将无法接受。
2.  **动态卷轴 (Dynamic Reels)**：如 Megaways 玩法，每列行数随机变化（2-7行），导致无法使用固定的矩阵逻辑，且组合数呈指数级增加。
3.  **稀有事件难以采样**：如果使用随机采样代替穷举，极高倍数的大奖（如 5000x）可能采样 1000万次都遇不到一次，导致高层级奖池为空。

---

## 2. 解决方案思路

我们需要从 **"全量预计算"** 转向 **"混合生成 (Hybrid Generation)"** 架构。

### 核心策略：拒绝采样 (Rejection Sampling) + 种子库 (Seed Pool)

#### 2.1 针对普通奖池（Loss, Tier 1-3）：实时拒绝采样
对于概率较高的事件（输、小奖），不需要预先存下来，**实时生成**即可。

**流程：**
1.  `_select_bucket` 决定本局目标是 `Win_Tier_2` (10x - 50x)。
2.  引擎随机生成一组停止位置 `stops = [rand(), rand(), ...]`。
3.  快速计算该结果的倍数。
4.  **判定：**
    -   如果倍数在 `Win_Tier_2` 范围内 -> **返回结果**。
    -   如果不在 -> **重试**（设置最大重试次数，如 100 次）。
5.  **兜底：** 如果重试 100 次仍未命中，返回一个预设的“安全结果”（如 Loss 或极小奖）。

*优点：无需内存，支持无限长的卷轴。*
*缺点：对于稀有事件（大奖），命中率极低，可能导致死循环或超时。*

#### 2.2 针对稀有奖池（Tier 4-5, Jackpot）：黄金种子库 (Golden Seeds)
对于概率极低的大奖，实时随机撞出来的概率太低。我们需要预先“埋藏”或“构造”这些结果。

**流程：**
1.  **离线挖掘/构造**：
    -   编写一个脚本，专门寻找或构造高倍数的中奖组合（例如：强制让 5 个 Wild 连成一线，反推停止位置）。
    -   将这些特殊的 `stops` 组合存入一个轻量级的 JSON/数据库，称为 **"Golden Seeds"**。
2.  **运行时**：
    -   当 `_select_bucket` 选中 `Win_Tier_5` 时。
    -   直接从 **Golden Seeds** 列表中随机取一个。

#### 2.3 混合架构图示

```mermaid
graph TD
    A[Spin Request] --> B{RTP Controller Select Bucket}
    B -->|Target: Loss / Small Win| C[Rejection Sampling (Real-time)]
    B -->|Target: Big Win / Jackpot| D[Golden Seed Pool (Pre-defined)]
    
    C --> E{Match Target?}
    E -->|Yes| F[Return Result]
    E -->|No (Retry < N)| C
    E -->|No (Timeout)| G[Fallback to Safe Loss]
    
    D --> F
```

---

## 3. 动态卷轴 (Dynamic Reels / Megaways) 适配

对于卷轴高度变化的游戏（如每列 2-7 个符号），需要将 **"布局生成"** 与 **"符号填充"** 解耦。

### 3.1 数据结构变更
配置不再是固定的 `3x5`，而是定义每列的 **最大高度** 和 **权重**。

```json
"layout_config": {
    "cols": 6,
    "rows_range": [2, 7],  // 每列可能是 2 到 7 行
    "ways_to_win": true    // 通常配合路单玩法 (Ways) 而非线 (Lines)
}
```

### 3.2 生成流程
1.  **Step 1: 确定布局 (Layout)**
    -   随机生成每列的高度，例如 `[2, 5, 3, 7, 4, 2]`。
    -   计算当前的 "Ways" 总数（如 $2*5*3*7*4*2 = 1680$ 路）。
2.  **Step 2: 填充符号 (Fill)**
    -   根据每列的实际高度，从卷轴带上截取对应数量的符号。
    -   注意：卷轴带逻辑不变，只是截取的窗口大小变了。
3.  **Step 3: 算奖 (Evaluate)**
    -   使用 **深度优先搜索 (DFS)** 或 **邻接检查** 来计算中奖，而不是查表（Lines）。
    -   *路单规则：只要相邻列存在相同符号即可，不限位置。*

---

## 4. 实施路线图 (Roadmap)

### 第一阶段：引入拒绝采样 (当前代码改造)
1.  保留 `initialize_buckets`，但只让它生成少量样本用于统计 RTP。
2.  修改 `spin` 逻辑：
    -   先尝试从 `buckets` 里取（如果桶里有数据）。
    -   如果桶是空的（或为了节省内存没存），进入 `_spin_until_match(target_tier)` 函数。
    -   该函数执行 "随机生成 -> 校验 -> 重试" 循环。

### 第二阶段：引入大奖库
1.  创建一个 `special_outcomes.json`。
2.  手动配置几个高倍数局面的 `stops` 索引。
3.  在引擎加载时读取这个文件到 `self.golden_seeds`。

### 第三阶段：支持动态布局
1.  修改 `_get_matrix_from_stops`，使其接受一个 `layout` 参数。
2.  新增 `_calculate_ways_win` 替代 `_calculate_line_win`。

---

## 5. 总结

| 特性 | 现有方案 (Pre-calc) | 推荐方案 (Hybrid) |
| :--- | :--- | :--- |
| **内存占用** | 高 (随卷轴长度指数增长) | **极低** (仅存配置和大奖种子) |
| **启动速度** | 慢 (需计算所有组合) | **极快** (毫秒级) |
| **灵活性** | 差 (仅限固定网格) | **极高** (支持任意形状) |
| **大奖控制** | 依赖运气 (采样可能漏掉大奖) | **精准** (通过种子库精确控制) |
| **CPU 消耗** | 旋转时低，启动时高 | 旋转时略高 (需多次重试)，启动低 |

建议优先实施 **第一阶段**，在 `OutcomeEngine` 中增加 `_generate_on_demand` 方法，作为从桶中取不到数据时的备选方案。
